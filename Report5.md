# Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Author: Musin Vladislava

----

## Theory

Converting a context-free grammar (CFG) to Chomsky normal form (CNF) is a fundamental process in formal language theory and computational linguistics. Chomsky normal form imposes strict structural constraints on CFGs, simplifying parsing algorithms and enabling efficient processing in various computational contexts. This conversion involves transforming production rules to adhere to two key restrictions:

All productions must be in one of two forms:
A -> BC, where A, B, and C are non-terminal symbols.
A -> a, where A is a non-terminal symbol and a is a terminal symbol.
No nullable (ε) productions are allowed:
This means that no production can derive the empty string ε.
The conversion process typically involves several steps, each designed to gradually reshape the grammar into compliance with these restrictions.

Firstly, the grammar may need to be augmented with additional rules to handle start symbols and terminal symbols. Often, this involves introducing a new start symbol that derives the original start symbol, as well as rules for each terminal symbol to itself.

Secondly, the grammar is modified to eliminate nullable productions. This involves iteratively identifying and removing nullable symbols, as well as updating existing rules to reflect these changes.

Next, unit productions (A -> B) are eliminated by replacing them with their corresponding productions. This process may require multiple iterations until no unit productions remain.

After handling nullable and unit productions, the grammar is transformed to ensure that all productions have either one or two non-terminal symbols on the right-hand side. This may involve introducing new non-terminal symbols and splitting long productions into multiple smaller ones.

Throughout these transformations, it's crucial to maintain equivalence with the original grammar, ensuring that the language generated by the resulting CNF grammar remains the same.

Once all transformations are complete, the grammar emerges in Chomsky normal form, characterized by its simplified structure and adherence to strict production rules. This form facilitates efficient parsing algorithms, grammar analysis, and other computational tasks, making it a valuable tool in formal language theory and natural language processing.


## Objectives:

* Learn about Chomsky Normal Form (CNF) [1].
* Get familiar with the approaches of normalizing a grammar.
* Implement a method for normalizing an input grammar by the rules of CNF.

## Implementation description

### 1. Code description

The program contains 2 files: main.py and helper.py, which Python scripts that together form a program for manipulating context-free grammar productions. Let's break down their functionality:

#### main.py
* Imports: This script imports the sys module and a custom module helper for additional functions.
* Global Variables: It defines global variables like left and right for indexing production rules, empty lists K, V, and Productions, and a list variablesJar containing letters from 'A' to 'Z'.
* Functions:
  
    isUnitary(rule, variables): Checks if a production rule is unitary.

  isSimple(rule): Checks if a production rule is simple. 

  START(productions, variables): Adds the start symbol production rule.

  TERM(productions, variables): Replaces rules containing both terminals and variables.

  BIN(productions, variables): Eliminates non-binary rules.

  DEL(productions): Deletes non-terminal rules.

  unit_routine(rules, variables): Routine for handling unit productions.

  UNIT(productions, variables): Eliminates unitary rules iteratively.

* Main Block:
    Loads a grammar model from a file specified by modelPath.

    Performs grammar transformations: start symbol addition, terminal replacement, binary conversion, deletion of non-terminal rules, and elimination of unitary rules.
    
    Prints the resulting productions and their count.

    Writes the resulting productions to an output file.

#### helper.py
* Imports: This script doesn't import any external modules.
  * Functions:
  
    union(lst1, lst2): Returns the union of two lists.
  
    loadModel(modelPath): Loads the grammar model from a file.
  
    cleanProduction(expression): Cleans and formats the production rules.
  
    cleanAlphabet(expression): Cleans and formats the alphabet.
  
    seekAndDestroy(target, productions): Deletes rules containing a specific target
  
    setupDict(productions, variables, terms): Sets up a dictionary for base productions.
  
    rewrite(target, production): Rewrites productions by replacing a target.
  
    dict2Set(dictionary): Converts a dictionary to a set of tuples.
  
    pprintRules(rules): Pretty-prints production rules.
  
    prettyForm(rules): Formats production rules into a readable form.
  
#### Overall Functionality:
main.py is the main script that orchestrates the grammar transformations.
helper.py contains various utility functions used in main.py for loading, cleaning, and manipulating grammar productions.
Together, these scripts form a tool for performing transformations on context-free grammar productions, such as converting grammars to Chomsky normal form or removing non-terminal rules.

### 2 How to use
The script must be called in a form like ``CFG2CNF.py model.txt``, and it produces an ``out.txt`` file.
The Grammar G=(V, T, P, S) is read by a `.txt` file, so need a certain formattation, that follow:
```
Terminals:
+ - ( ) ^ number variable
Variables:
Expr Term AddOp MulOp Factor Primary
Productions:
Expr -> Term | Expr AddOp Term | AddOp Term;
Term -> Factor | Term MulOp Factor;
Factor -> Primary | Factor ^ Primary;
Primary -> number | variable;
Primary -> ( Expr );
AddOp -> + | -;
MulOp -> * | /
```
Is important to:
* Use spaces between symbols, one space, not more
* use te ';' character to separate rows in productions: don't use for the last.

Where is obvious how T, V and P are loaded (text after *Terminals/Variables/Productions:*), maybe less obviously is selected S as the first Variable from the left.
**N.B.** the ε-rule symbol is fixed and it's simplly ``e``
The output corresponding to the above example is:
```
AddOp -> + | -
Term -> Term B1 | Primary | Factor C1
MulOp -> * | /
Expr -> Expr A1 | AddOp Term | Term B1 | Primary | Factor C1
S0 -> Expr A1 | AddOp Term | Term B1 | Primary | Factor C1
Primary -> Y | variable | X D1
A1 -> AddOp Term
B1 -> MulOp Factor
W -> )
Factor -> Primary | Factor C1
Y -> number
X -> (
C1 -> Z Primary
Z -> ^
D1 -> Expr W
```

### 3 The Routine
1. **START**: add ``S0->S`` production
2. **TERM**: replace terminal symbols with variables in production containing boht on the right
3. **BIN**: make rules binaries, in other words break in more parts rules which right side is longer than 2
4. **DEL**: eliminate ε-rules and eventually rearrange other productions
5. **UNIT**: remove all production which the right side is only a variable



## Conclusions 

Through the process of developing the Python scripts for converting context-free grammars to Chomsky normal form, I've deepened my understanding of formal language theory while enhancing my programming skills, enabling me to tackle future challenges at the intersection of theoretical linguistics and computational methods.
